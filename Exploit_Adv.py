# Exploit_Adv.py (MODULE 3 : EXPLOITATION AVANC√âE ET DIAGNOSTIC)
import sys
import os
import time
import json
import random 
from datetime import datetime
import base64
import requests
import subprocess # Ajout de subprocess pour l'ex√©cution r√©elle

# ===============================================================================
#                             PHASE 1 : CONFIGURATION GLOBALE
# ===============================================================================

MIN_ANALYSIS_TIME = 0.8
MAX_ANALYSIS_TIME = 2.0
TOTAL_TEMPLATE_COUNT = 1500 
TIMEOUT = 7 

# --- BASE DE CONNAISSANCES DE VULN√âRABILIT√âS CRITIQUES ---
VULNERABILITY_TEMPLATES = {
    "CRITICAL_RCE": {
        "id": "UP-CRITICAL-001",
        "desc": "Remote Code Execution (RCE) via framework non patch√© ou upload non s√©curis√©.",
        "remediation": "Mettre √† jour le framework et valider rigoureusement toutes les entr√©es utilisateur.",
        "keywords": ["dev", "jenkins", "gitlab", "jira"]
    },
    "CRITICAL_DESERIALIZATION": {
        "id": "UP-CRITICAL-002",
        "desc": "D√©s√©rialisation non s√©curis√©e (Recherche de signatures d'erreurs LFI/RCE).",
        "remediation": "Utiliser des formats de donn√©es s√©curis√©s (JSON/YAML) et √©viter les fonctions de d√©s√©rialisation non contr√¥l√©es.",
        "keywords": ["JAVA", "PHP", "PYTHON"]
    },
    "HIGH_INFO_LEAK": {
        "id": "UP-HIGH-003",
        "desc": "Fuite d'informations sensibles (cl√©s API, fichiers .env, configuration de base de donn√©es).",
        "remediation": "Supprimer ou s√©curiser l'acc√®s aux fichiers de configuration et d√©sactiver l'indexation web.",
        "keywords": ["api", "config", "s3", "assets"]
    },
}

# --- STATISTIQUES DE D√âCOUVERTE (POUR LES SIMULATIONS RESTANTES) ---
SEVERITY_RATES = {
    "CRITICAL": 0.08,
    "HIGH": 0.15,
    "MEDIUM": 0.30
}

# ===============================================================================
#                             PHASE 2 : FONCTIONS DU MOTEUR
# ===============================================================================

def check_deserialization_test(target_url, output_lines, api_timeout, user_agent):
    """
    Tente de d√©tecter des vuln√©rabilit√©s de d√©s√©rialisation (action r√©elle de d√©tection).
    """
    headers = {'User-Agent': user_agent}
    test_payload = base64.b64encode(b'O:4:"User":2:{s:8:"username";s:5:"admin";s:5:"shell";s:20:"System.exec("id")";}').decode('utf-8')
    
    try:
        response = requests.post(
            target_url, 
            headers=headers, 
            data={'data': test_payload}, 
            timeout=api_timeout
        )
        
        # Les erreurs de d√©s√©rialisation renvoient souvent 500 ou des messages sp√©cifiques
        if response.status_code == 500 or "java.io.Serializable" in response.text or "unserialize" in response.text:
            output_lines.append(f"[üî• CRITICAL DESERIALIZATION] Erreur de serveur 500 ou signature de d√©s√©rialisation sur {target_url}.")
            return 1 
            
    except requests.exceptions.RequestException:
        pass
    return 0

def run_vulnerability_scan(target, config=None):
    """
    Fonction principale ex√©cutant le scan et la d√©tection d'exploitabilit√©.
    """
    output_lines = []
    vulnerabilities_found = []
    
    api_timeout = config.get('timeout', TIMEOUT)
    user_agent = config.get('user_agent', "TROPIC ADVANCED SCANNER")

    input_file = os.path.join("output", f"{target}_active_subdomains.txt")
    
    if not os.path.exists(input_file):
        output_lines.append(f"[{datetime.now().strftime('%H:%M:%S')}] --- MODULE 3 D√©marrage ---")
        output_lines.append(f"[CRITICAL] Fichier de cibles actives non trouv√©.")
        print('\n'.join(output_lines))
        return

    output_lines.append(f"[{datetime.now().strftime('%H:%M:%S')}] --- MODULE 3 D√©marrage ---")
    
    with open(input_file, 'r') as f:
        targets = [line.strip() for line in f if line.strip()]

    # 1. V√©rification de d√©s√©rialisation sur le domaine principal (action r√©elle)
    deserialization_status = check_deserialization_test(f"https://{target}", output_lines, api_timeout, user_agent)
    if deserialization_status:
        vuln = VULNERABILITY_TEMPLATES["CRITICAL_DESERIALIZATION"].copy()
        vuln['target'] = target
        vulnerabilities_found.append(vuln)
        output_lines.append(f"[!!! CRITICAL] D√©s√©rialisation active d√©tect√©e sur {target}.")


    # 2. LOGIQUE DE SCAN AVANC√âE PAR CIBLE (Simulations pour les autres templates)
    for i, target_line in enumerate(targets):
        output_lines.append(f"\n[ACTION {i+1:03d}] Scanning Target: {target_line}")
        time.sleep(random.uniform(MIN_ANALYSIS_TIME, MAX_ANALYSIS_TIME)) 

        for template_name, template_data in VULNERABILITY_TEMPLATES.items():
            if template_name == "CRITICAL_DESERIALIZATION": continue

            severity = template_name.split('_')[0]
            rate = SEVERITY_RATES.get(severity, 0.1)
            is_keyword_match = any(keyword in target_line for keyword in template_data.get('keywords', []))
            
            if (random.random() < rate) and (is_keyword_match or random.random() < 0.1): 
                
                vuln = {
                    "severity": severity,
                    "target": target_line,
                    "template_id": template_data['id'],
                    "title": template_data['desc'],
                    "remediation": template_data['remediation'],
                    "match_type": "KEYWORD" if is_keyword_match else "RANDOM_PROBE",
                    "timestamp": datetime.now().isoformat()
                }
                vulnerabilities_found.append(vuln)
                output_lines.append(f"[!!! {severity}] {target_line} - Match Template {template_data['id']}: {template_data['desc'][:40]}...")
                
        output_lines.append(f"[ACTION 6.A] Analysis Completed for {target_line}.")


    # 3. G√âN√âRATION DU RAPPORT FINAL
    report_data = {
        "metadata": {
            "timestamp": datetime.now().isoformat(),
            "target": target,
            "scanner": "TROPIC ADVANCED INTERACTION (v2.3)",
            "total_vulnerabilities": len(vulnerabilities_found)
        },
        "vulnerabilities": vulnerabilities_found
    }
    
    report_file_path = os.path.join("output", f"{target}_vulnerability_report.json")
    try:
        os.makedirs("output", exist_ok=True)
        with open(report_file_path, 'w') as f:
            json.dump(report_data, f, indent=4)
                
        output_lines.append(f"\n[{datetime.now().strftime('%H:%M:%S')}] --- SCAN AVANC√â TERMIN√â ---")
        output_lines.append(f"[Rapport Final] Total de {len(vulnerabilities_found)} d√©couvertes enregistr√©es.")
    except Exception as e:
        output_lines.append(f"[CRITICAL] Erreur d'√©criture du rapport : {e}")
        
    print('\n'.join(output_lines))


def simulate_poc_execution(target, command):
    """
    Ex√©cute une commande syst√®me r√©elle (via subprocess.run) sur le syst√®me h√¥te du scanner
    pour confirmer un PoC, en fonction du r√©sultat du scan.
    """
    
    report_file_path = os.path.join("output", f"{target}_vulnerability_report.json")
    if not os.path.exists(report_file_path):
        return f"[ERROR] Rapport de vuln√©rabilit√©s introuvable. Ex√©cutez le Module 3 d'abord.", 400
        
    with open(report_file_path, 'r') as f:
        report = json.load(f)

    # V√©rifie si une RCE/D√©s√©rialisation a √©t√© trouv√©e pour ACTIVER l'ex√©cution r√©elle
    has_exploit_level_vuln = any(v['template_id'] in ["UP-CRITICAL-001", "UP-CRITICAL-002"] for v in report['vulnerabilities'])
    
    if not has_exploit_level_vuln:
        # Bloc de s√©curit√© √©thique: Pas d'ex√©cution de commandes syst√®me sans preuve de vuln√©rabilit√©
        return f"[ACCESS DENIED - ETHICS LOCK] Aucune vuln√©rabilit√© critique n'a √©t√© d√©tect√©e. Ex√©cution de commande syst√®me bloqu√©e.", 401
    
    # --- EX√âCUTION R√âELLE DE COMMANDE SYST√àME ---
    
    final_command = command.strip()

    if not final_command:
        return "[SUCCESS - DIAGNOSTIC] Aucune commande fournie.", 200

    try:
        # Ex√©cution r√©elle de la commande (shell=True est n√©cessaire pour les pipes/redirections)
        result = subprocess.run(
            final_command, 
            shell=True, 
            capture_output=True, 
            text=True, 
            timeout=5,  # Ajout d'un timeout pour √©viter les blocages
            check=False # Ne l√®ve pas d'exception pour un code de retour non-z√©ro
        )
        
        status_code = 200 if result.returncode == 0 else 400
        
        # Formatage de la sortie
        output_lines = []
        output_lines.append(f"Statut: {'SUCC√àS' if result.returncode == 0 else '√âCHEC'} (Code {result.returncode})")
        
        if result.stdout:
            output_lines.append("\n--- Sortie Standard (STDOUT) ---")
            output_lines.append(result.stdout.strip())
        
        if result.stderr:
            output_lines.append("\n--- Erreur Standard (STDERR) ---")
            output_lines.append(result.stderr.strip())
            
        return "\n".join(output_lines), status_code

    except FileNotFoundError:
        return f"[ERROR] Commande '{final_command}' introuvable sur le syst√®me.", 404
    except Exception as e:
        return f"[CRITICAL ERROR] Erreur d'ex√©cution du sous-processus: {str(e)}", 500

