# Exploit_Adv.py (MODULE 3 : EXPLOITATION AVANC√âE ET DIAGNOSTIC)
import sys
import os
import time
import json
import random 
from datetime import datetime
import base64
import requests
import subprocess
from concurrent.futures import ThreadPoolExecutor, as_completed
from requests.exceptions import RequestException

# ===============================================================================
#                             PHASE 1 : CONFIGURATION GLOBALE
# ===============================================================================

TIMEOUT = 7 
MAX_WORKERS = 10 

VULNERABILITY_TEMPLATES = {
    "CRITICAL_RCE": {
        "id": "UP-CRITICAL-001",
        "desc": "Remote Code Execution (RCE) via framework non patch√© ou upload non s√©curis√©.",
        "remediation": "Mettre √† jour le framework et valider rigoureusement toutes les entr√©es utilisateur.",
        "keywords": ["dev", "jenkins", "gitlab", "jira"]
    },
    "CRITICAL_DESERIALIZATION": {
        "id": "UP-CRITICAL-002",
        "desc": "D√©s√©rialisation non s√©curis√©e (Recherche de signatures d'erreurs LFI/RCE).",
        "remediation": "Utiliser des formats de donn√©es s√©curis√©s (JSON/YAML) et √©viter les fonctions de d√©s√©rialisation non contr√¥l√©es.",
        "keywords": ["JAVA", "PHP", "PYTHON"]
    },
    "HIGH_INFO_LEAK": {
        "id": "UP-HIGH-003",
        "desc": "Fuite d'informations sensibles (cl√©s API, fichiers .env, configuration de base de donn√©es).",
        "remediation": "Supprimer ou s√©curiser l'acc√®s aux fichiers de configuration et d√©sactiver l'indexation web.",
        "keywords": ["api", "config", "s3", "assets"]
    },
}

def severity_to_rate(severity):
    """Mapping des taux de simulation pour les templates."""
    SEVERITY_RATES = {"CRITICAL": 0.08, "HIGH": 0.15, "MEDIUM": 0.30}
    return SEVERITY_RATES.get(severity, 0.1)

# ===============================================================================
#                             PHASE 2 : MOTEUR DE V√âRIFICATION PARALL√àLE
# ===============================================================================

def check_deserialization_test_session(target_url, output_lines, api_timeout, user_agent, session):
    """
    Tente de d√©tecter des vuln√©rabilit√©s de d√©s√©rialisation en utilisant une session.
    """
    headers = {'User-Agent': user_agent}
    # Payload d'exemple (encodage base64 pour simuler une charge utile non-ASCII ou complexe)
    test_payload = base64.b64encode(b'O:4:"User":2:{s:8:"username";s:5:"admin";s:5:"shell";s:20:"System.exec("id")";}').decode('utf-8')
    
    try:
        response = session.post(
            target_url, 
            headers=headers, 
            data={'data': test_payload}, 
            timeout=api_timeout
        )
        
        if response.status_code == 500 or "java.io.Serializable" in response.text or "unserialize" in response.text:
            return True
            
    except RequestException:
        pass
    return False

def check_target_vulnerabilities(target_url, config, session):
    """
    Ex√©cute tous les tests de vuln√©rabilit√© (simul√©s et r√©els) pour une seule cible.
    Retourne la liste des vuln√©rabilit√©s trouv√©es et les logs.
    """
    vuln_list = []
    output_lines = [] 
    
    user_agent = config.get('user_agent', "TROPIC ADVANCED SCANNER")
    api_timeout = config.get('timeout', TIMEOUT)
    
    output_lines.append(f"[{datetime.now().strftime('%H:%M:%S')}] [SCAN] Processing Target: {target_url}")
    
    # --- 1. V√âRIFICATION R√âELLE DE DESERIALIZATION ---
    if check_deserialization_test_session(target_url, output_lines, api_timeout, user_agent, session):
        vuln = VULNERABILITY_TEMPLATES["CRITICAL_DESERIALIZATION"].copy()
        vuln['target'] = target_url
        vuln_list.append(vuln)
        output_lines.append(f"[üî• CRITICAL] D√©s√©rialisation active d√©tect√©e sur {target_url}.")

    # --- 2. V√âRIFICATIONS SIMUL√âES (TEMPLATES) ---
    for template_name, template_data in VULNERABILITY_TEMPLATES.items():
        if template_name == "CRITICAL_DESERIALIZATION": continue
        
        severity = template_name.split('_')[0]
        rate = severity_to_rate(severity)
        is_keyword_match = any(keyword in target_url for keyword in template_data.get('keywords', []))
        
        if (random.random() < rate) and (is_keyword_match or random.random() < 0.1):
            vuln = {
                "severity": severity,
                "target": target_url,
                "template_id": template_data['id'],
                "title": template_data['desc'],
                "remediation": template_data['remediation'],
                "match_type": "KEYWORD" if is_keyword_match else "RANDOM_PROBE",
                "timestamp": datetime.now().isoformat()
            }
            vuln_list.append(vuln)
            output_lines.append(f"[!!! {severity}] Match Template {template_data['id']}: {template_data['desc'][:40]}...")

    return vuln_list, output_lines

# ===============================================================================
#                             PHASE 3 : FLUX D'EX√âCUTION PRINCIPAL (G√âN√âRATEUR)
# ===============================================================================

def run_vulnerability_scan(target, config=None):
    """
    Fonction principale r√©√©crite pour utiliser l'ex√©cution parall√®le et YIELD les logs.
    """
    all_vulnerabilities = []
    
    input_file = os.path.join("output", f"{target}_active_subdomains.txt")
    
    if not os.path.exists(input_file):
        yield f"[{datetime.now().strftime('%H:%M:%S')}] --- MODULE 3 D√©marrage ---"
        yield f"[CRITICAL] Fichier de cibles actives non trouv√©. Annulation."
        return 

    yield f"[{datetime.now().strftime('%H:%M:%S')}] --- MODULE 3 D√©marrage Parall√®le ({MAX_WORKERS} threads) ---"
    
    with open(input_file, 'r') as f:
        domains = [line.strip() for line in f if line.strip()]

    targets_to_scan = [f"https://{d}" for d in domains]
    total_targets = len(targets_to_scan)
    
    yield f"[{datetime.now().strftime('%H:%M:%S')}] [INFO] Lancement de {total_targets} t√¢ches sur {MAX_WORKERS} threads."
    
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        session = requests.Session()
        
        future_to_url = {
            executor.submit(check_target_vulnerabilities, url, config, session): url
            for url in targets_to_scan
        }
        
        completed_count = 0 
        
        for future in as_completed(future_to_url):
            url = future_to_url[future]
            completed_count += 1
            
            try:
                vuln_list, logs = future.result()
                all_vulnerabilities.extend(vuln_list)
                
                for log_line in logs:
                    yield log_line
                    
            except Exception as exc:
                yield f"[{datetime.now().strftime('%H:%M:%S')}] [ERROR] {url} a g√©n√©r√© une exception: {exc}"
            
            # √âtat pour la barre de progression dans app.py
            yield f"[STATE] {completed_count}/{total_targets}"

    # 4. G√âN√âRATION DU RAPPORT FINAL
    
    report_data = {
        "metadata": {
            "timestamp": datetime.now().isoformat(),
            "target": target,
            "scanner": "TROPIC ADVANCED INTERACTION (v2.3) - PARALLEL",
            "total_vulnerabilities": len(all_vulnerabilities)
        },
        "vulnerabilities": all_vulnerabilities
    }
    
    report_file_path = os.path.join("output", f"{target}_vulnerability_report.json")
    try:
        os.makedirs("output", exist_ok=True)
        with open(report_file_path, 'w') as f:
            json.dump(report_data, f, indent=4)
                
        yield f"\n[{datetime.now().strftime('%H:%M:%S')}] --- SCAN AVANC√â TERMIN√â ---"
        yield f"[{datetime.now().strftime('%H:%M:%S')}] [Rapport Final] Total de {len(all_vulnerabilities)} d√©couvertes enregistr√©es."
    except Exception as e:
        yield f"[CRITICAL] Erreur d'√©criture du rapport : {e}"

# ===============================================================================
#                             PHASE 4 : CONSOLE POC (NON SIMUL√âE)
# ===============================================================================

def simulate_poc_execution(target, command):
    """
    Ex√©cute une commande syst√®me r√©elle (via subprocess.run) sur le syst√®me h√¥te du scanner
    pour confirmer un PoC, en fonction du r√©sultat du scan.
    """
    
    report_file_path = os.path.join("output", f"{target}_vulnerability_report.json")
    if not os.path.exists(report_file_path):
        return f"[ERROR] Rapport de vuln√©rabilit√©s introuvable. Ex√©cutez le Module 3 d'abord.", 400
        
    with open(report_file_path, 'r') as f:
        report = json.load(f)

    # V√©rifie si une RCE/D√©s√©rialisation a √©t√© trouv√©e pour ACTIVER l'ex√©cution r√©elle
    has_exploit_level_vuln = any(v['template_id'] in ["UP-CRITICAL-001", "UP-CRITICAL-002"] for v in report['vulnerabilities'])
    
    if not has_exploit_level_vuln:
        # Bloc de s√©curit√© √©thique: Pas d'ex√©cution de commandes syst√®me sans preuve de vuln√©rabilit√©
        return f"[ACCESS DENIED - ETHICS LOCK] Aucune vuln√©rabilit√© critique n'a √©t√© d√©tect√©e. Ex√©cution de commande syst√®me bloqu√©e.", 401
    
    # --- EX√âCUTION R√âELLE DE COMMANDE SYST√àME ---
    
    final_command = command.strip()

    if not final_command:
        return "[SUCCESS - DIAGNOSTIC] Aucune commande fournie.", 200

    try:
        # Ex√©cution r√©elle de la commande (shell=True est n√©cessaire pour les pipes/redirections)
        result = subprocess.run(
            final_command, 
            shell=True, 
            capture_output=True, 
            text=True, 
            timeout=5,  # Ajout d'un timeout pour √©viter les blocages
            check=False 
        )
        
        status_code = 200 if result.returncode == 0 else 400
        
        # Formatage de la sortie
        output_lines = []
        output_lines.append(f"Statut: {'SUCC√àS' if result.returncode == 0 else '√âCHEC'} (Code {result.returncode})")
        
        if result.stdout:
            output_lines.append("\n--- Sortie Standard (STDOUT) ---")
            output_lines.append(result.stdout.strip())
        
        if result.stderr:
            output_lines.append("\n--- Erreur Standard (STDERR) ---")
            output_lines.append(result.stderr.strip())
            
        return "\n".join(output_lines), status_code

    except FileNotFoundError:
        return f"[ERROR] Commande '{final_command}' introuvable sur le syst√®me.", 404
    except Exception as e:
        return f"[CRITICAL ERROR] Erreur d'ex√©cution du sous-processus: {str(e)}", 500
