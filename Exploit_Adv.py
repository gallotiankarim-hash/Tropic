# Exploit_Adv_Refonte.py (MODULE 3 : EXPLOITATION AVANC√âE ET DIAGNOSTIC)

import sys
import os
import time
import json
import random 
import requests
import subprocess
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from requests.exceptions import RequestException

# ===============================================================================
#                             PHASE 1 : CONFIGURATION GLOBALE
# ===============================================================================

TIMEOUT = 7 
# D√©finir le nombre de threads/workers pour la parall√©lisation
MAX_WORKERS = 10 

VULNERABILITY_TEMPLATES = {
    # ... (Vos templates restent ici)
    "CRITICAL_RCE": {
        "id": "UP-CRITICAL-001",
        "desc": "Remote Code Execution (RCE) via framework non patch√© ou upload non s√©curis√©.",
        "remediation": "Mettre √† jour le framework et valider rigoureusement toutes les entr√©es utilisateur.",
        "keywords": ["dev", "jenkins", "gitlab", "jira"]
    },
    "CRITICAL_DESERIALIZATION": {
        "id": "UP-CRITICAL-002",
        "desc": "D√©s√©rialisation non s√©curis√©e (Recherche de signatures d'erreurs LFI/RCE).",
        "remediation": "Utiliser des formats de donn√©es s√©curis√©s (JSON/YAML) et √©viter les fonctions de d√©s√©rialisation non contr√¥l√©es.",
        "keywords": ["JAVA", "PHP", "PYTHON"]
    },
    "HIGH_INFO_LEAK": {
        "id": "UP-HIGH-003",
        "desc": "Fuite d'informations sensibles (cl√©s API, fichiers .env, configuration de base de donn√©es).",
        "remediation": "Supprimer ou s√©curiser l'acc√®s aux fichiers de configuration et d√©sactiver l'indexation web.",
        "keywords": ["api", "config", "s3", "assets"]
    },
}

# ===============================================================================
#                             PHASE 2 : MOTEUR DE V√âRIFICATION PARALL√àLE
# ===============================================================================

def check_target_vulnerabilities(target_url, config, session):
    """
    Ex√©cute tous les tests de vuln√©rabilit√© (simul√©s et r√©els) pour une seule cible.
    Retourne la liste des vuln√©rabilit√©s trouv√©es pour cette cible.
    """
    vuln_list = []
    output_lines = [] # Log temporaire pour cette cible
    
    user_agent = config.get('user_agent', "TROPIC ADVANCED SCANNER")
    api_timeout = config.get('timeout', TIMEOUT)
    
    # Simuler le temps de travail avant l'ex√©cution (pour le r√©alisme)
    time.sleep(random.uniform(0.5, 1.5)) 

    # --- 1. V√âRIFICATION R√âELLE DE DESERIALIZATION ---
    # Nous laissons cette v√©rification bloquante pour l'exemple
    if 'deserialization_check' not in target_url: # √âvite de la relancer pour chaque test simul√©
        if check_deserialization_test_session(target_url, output_lines, api_timeout, user_agent, session):
            vuln = VULNERABILITY_TEMPLATES["CRITICAL_DESERIALIZATION"].copy()
            vuln['target'] = target_url
            vuln_list.append(vuln)
            output_lines.append(f"[üî• CRITICAL] D√©s√©rialisation active d√©tect√©e sur {target_url}.")

    # --- 2. V√âRIFICATIONS SIMUL√âES (TEMPLATES) ---
    for template_name, template_data in VULNERABILITY_TEMPLATES.items():
        if template_name == "CRITICAL_DESERIALIZATION": continue # D√©j√† g√©r√©
        
        severity = template_name.split('_')[0]
        rate = severity_to_rate(severity) # Utilise la fonction de taux
        is_keyword_match = any(keyword in target_url for keyword in template_data.get('keywords', []))
        
        # Logique de d√©tection simul√©e (m√©lange de taux et de mots-cl√©s)
        if (random.random() < rate) and (is_keyword_match or random.random() < 0.1):
            vuln = {
                "severity": severity,
                "target": target_url,
                "template_id": template_data['id'],
                "title": template_data['desc'],
                "remediation": template_data['remediation'],
                "match_type": "KEYWORD" if is_keyword_match else "RANDOM_PROBE",
                "timestamp": datetime.now().isoformat()
            }
            vuln_list.append(vuln)
            output_lines.append(f"[!!! {severity}] {target_url} - Match Template {template_data['id']}.")

    return vuln_list, output_lines

def check_deserialization_test_session(target_url, output_lines, api_timeout, user_agent, session):
    """
    Tente de d√©tecter des vuln√©rabilit√©s de d√©s√©rialisation en utilisant une session.
    """
    headers = {'User-Agent': user_agent}
    test_payload = "..." # Payload de base64 non inclus ici pour concision
    
    try:
        response = session.post(
            target_url, 
            headers=headers, 
            data={'data': test_payload}, 
            timeout=api_timeout
        )
        
        if response.status_code == 500 or "java.io.Serializable" in response.text:
            return True
            
    except RequestException:
        pass
    return False

def severity_to_rate(severity):
    """Simple mapping des taux de simulation."""
    SEVERITY_RATES = {"CRITICAL": 0.08, "HIGH": 0.15, "MEDIUM": 0.30}
    return SEVERITY_RATES.get(severity, 0.1)


# ===============================================================================
#                             PHASE 3 : FLUX D'EX√âCUTION PRINCIPAL
# ===============================================================================

def run_vulnerability_scan(target, config=None):
    """
    Fonction principale r√©√©crite pour utiliser l'ex√©cution parall√®le.
    """
    output_lines = []
    all_vulnerabilities = []
    
    input_file = os.path.join("output", f"{target}_active_subdomains.txt")
    
    if not os.path.exists(input_file):
        # ... (Gestion de l'erreur)
        output_lines.append(f"[{datetime.now().strftime('%H:%M:%S')}] --- MODULE 3 D√©marrage ---")
        output_lines.append(f"[CRITICAL] Fichier de cibles actives non trouv√©.")
        print('\n'.join(output_lines))
        return

    output_lines.append(f"[{datetime.now().strftime('%H:%M:%S')}] --- MODULE 3 D√©marrage Parall√®le ---")
    
    with open(input_file, 'r') as f:
        domains = [line.strip() for line in f if line.strip()]

    # Pr√©parer les cibles compl√®tes (HTTPS par d√©faut)
    targets_to_scan = [f"https://{d}" for d in domains]
    
    # Utiliser ThreadPoolExecutor pour l'ex√©cution parall√®le des requ√™tes I/O-bound
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        
        # Utiliser une session pour tous les threads pour le pooling de connexion
        session = requests.Session()
        
        # Soumettre les t√¢ches au pool de threads
        future_to_url = {
            executor.submit(check_target_vulnerabilities, url, config, session): url
            for url in targets_to_scan
        }
        
        total_targets = len(targets_to_scan)
        output_lines.append(f"[INFO] Lancement de {total_targets} t√¢ches sur {MAX_WORKERS} threads.")
        
        # R√©cup√©rer les r√©sultats d√®s qu'ils sont compl√©t√©s (as_completed)
        for i, future in enumerate(as_completed(future_to_url)):
            url = future_to_url[future]
            try:
                vuln_list, logs = future.result()
                all_vulnerabilities.extend(vuln_list)
                output_lines.extend(logs)
                output_lines.append(f"[PROGRESS] T√¢che {i+1}/{total_targets} termin√©e pour {url}.")
            except Exception as exc:
                output_lines.append(f"[ERROR] {url} a g√©n√©r√© une exception: {exc}")

    # 4. G√âN√âRATION DU RAPPORT FINAL (Logique non modifi√©e)
    # ... (Votre logique de g√©n√©ration de rapport ici)
    
    report_data = {
        "metadata": {
            "timestamp": datetime.now().isoformat(),
            "target": target,
            "scanner": "TROPIC ADVANCED INTERACTION (v2.3) - PARALLEL",
            "total_vulnerabilities": len(all_vulnerabilities)
        },
        "vulnerabilities": all_vulnerabilities
    }
    
    # ... (Le reste de l'√©criture du fichier et du print final)
    report_file_path = os.path.join("output", f"{target}_vulnerability_report.json")
    try:
        os.makedirs("output", exist_ok=True)
        with open(report_file_path, 'w') as f:
            json.dump(report_data, f, indent=4)
                
        output_lines.append(f"\n[{datetime.now().strftime('%H:%M:%S')}] --- SCAN AVANC√â TERMIN√â ---")
        output_lines.append(f"[Rapport Final] Total de {len(all_vulnerabilities)} d√©couvertes enregistr√©es.")
    except Exception as e:
        output_lines.append(f"[CRITICAL] Erreur d'√©criture du rapport : {e}")
        
    print('\n'.join(output_lines))

# ===============================================================================
#                             PHASE 4 : CONSOLE POC (NON MODIFI√âE)
# ===============================================================================

# La fonction simulate_poc_execution reste inchang√©e (utilisation de subprocess.run)
# ...
